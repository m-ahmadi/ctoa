"use strict";(self.webpackChunkctrader_openapi_docs=self.webpackChunkctrader_openapi_docs||[]).push([[761],{5537:(e,n,s)=>{s.d(n,{A:()=>y});var t=s(6540),a=s(4164),r=s(5627),o=s(6347),c=s(372),i=s(604),l=s(1861),d=s(8749);function h(e){return t.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function u(e){const{values:n,children:s}=e;return(0,t.useMemo)(()=>{const e=n??function(e){return h(e).map(({props:{value:e,label:n,attributes:s,default:t}})=>({value:e,label:n,attributes:s,default:t}))}(s);return function(e){const n=(0,l.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,s])}function g({value:e,tabValues:n}){return n.some(n=>n.value===e)}function p({queryString:e=!1,groupId:n}){const s=(0,o.W6)(),a=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,i.aZ)(a),(0,t.useCallback)(e=>{if(!a)return;const n=new URLSearchParams(s.location.search);n.set(a,e),s.replace({...s.location,search:n.toString()})},[a,s])]}function m(e){const{defaultValue:n,queryString:s=!1,groupId:a}=e,r=u(e),[o,i]=(0,t.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!g({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const s=n.find(e=>e.default)??n[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:r})),[l,h]=p({queryString:s,groupId:a}),[m,f]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[s,a]=(0,d.Dv)(n);return[s,(0,t.useCallback)(e=>{n&&a.set(e)},[n,a])]}({groupId:a}),v=(()=>{const e=l??m;return g({value:e,tabValues:r})?e:null})();(0,c.A)(()=>{v&&i(v)},[v]);return{selectedValue:o,selectValue:(0,t.useCallback)(e=>{if(!g({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);i(e),h(e),f(e)},[h,f,r]),tabValues:r}}var f=s(9136);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=s(4848);function x({className:e,block:n,selectedValue:s,selectValue:t,tabValues:o}){const c=[],{blockElementScrollPositionUntilNextRender:i}=(0,r.a_)(),l=e=>{const n=e.currentTarget,a=c.indexOf(n),r=o[a].value;r!==s&&(i(n),t(r))},d=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const s=c.indexOf(e.currentTarget)+1;n=c[s]??c[0];break}case"ArrowLeft":{const s=c.indexOf(e.currentTarget)-1;n=c[s]??c[c.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":n},e),children:o.map(({value:e,label:n,attributes:t})=>(0,b.jsx)("li",{role:"tab",tabIndex:s===e?0:-1,"aria-selected":s===e,ref:e=>{c.push(e)},onKeyDown:d,onClick:l,...t,className:(0,a.A)("tabs__item",v.tabItem,t?.className,{"tabs__item--active":s===e}),children:n??e},e))})}function w({lazy:e,children:n,selectedValue:s}){const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=r.find(e=>e.props.value===s);return e?(0,t.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:r.map((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==s}))})}function j(e){const n=m(e);return(0,b.jsxs)("div",{className:(0,a.A)("tabs-container",v.tabList),children:[(0,b.jsx)(x,{...n,...e}),(0,b.jsx)(w,{...n,...e})]})}function y(e){const n=(0,f.A)();return(0,b.jsx)(j,{...e,children:h(e.children)},String(n))}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var t=s(6540);const a={},r=t.createContext(a);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},8481:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>g,frontMatter:()=>i,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"contacting-api/exchanging-messages","title":"Exchanging Messages","description":"Once we established a connection, we can send a","source":"@site/docs/02-contacting-api/03-exchanging-messages.mdx","sourceDirName":"02-contacting-api","slug":"/contacting-api/exchanging-messages","permalink":"/ctoa/contacting-api/exchanging-messages","draft":false,"unlisted":false,"editUrl":"https://github.com/m-ahmadi/ctoa/blob/main/docs/02-contacting-api/03-exchanging-messages.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"sidebar","previous":{"title":"Establishing a Connection","permalink":"/ctoa/contacting-api/establishing-connection"},"next":{"title":"Acquiring Credentials","permalink":"/ctoa/contacting-api/acquiring-credentials"}}');var a=s(4848),r=s(8453),o=s(5537),c=s(9329);const i={},l="Exchanging Messages",d={},h=[{value:"WebSocket Basics",id:"websocket-basics",level:2},{value:"Underlying Type of Messages",id:"underlying-type-of-messages",level:3},{value:"Format of Messages",id:"format-of-messages",level:2},{value:"Sending the First Message",id:"sending-the-first-message",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"exchanging-messages",children:"Exchanging Messages"})}),"\n",(0,a.jsxs)(n.p,{children:["Once we ",(0,a.jsx)(n.a,{href:"./establishing-connection",children:"established a connection"}),", we can send a\nmessage to the server. You might be wondering what we mean by a message and how\nare we going to send it."]}),"\n",(0,a.jsx)(n.h2,{id:"websocket-basics",children:"WebSocket Basics"}),"\n",(0,a.jsx)(n.p,{children:"In order to better understand the mechanism of sending messages, let's forget\nabout the cTrader OpenAPI server for the moment and connect to another server."}),"\n",(0,a.jsxs)(n.p,{children:["The endpoint that we're going to connect to is ",(0,a.jsx)(n.code,{children:"'wss://echo.websocket.org'"}),".\nThis is what's called an echo server, meaning, whatever message the client\nsends, it will send the exact same message back to the client."]}),"\n",(0,a.jsx)(n.p,{children:'Once the connection is open, we start sending the messages. Notice that we\'re\nnow "listening" for messages that server is sending back.'}),"\n",(0,a.jsxs)(o.A,{children:[(0,a.jsx)(c.A,{value:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const ws = new WebSocket('wss://echo.websocket.org');\nconst { log } = console;\n\nws.onopen = function () {\n  log('connected to server');\n\n  let msg = 'hello';\n  ws.send(msg);\n  log('client sent a message:', msg);\n\n  msg = 'hi';\n  ws.send(msg);\n  log('client sent a message:', msg);\n};\n\nws.onmessage = function (event) {\n  const serverMsg = event.data;\n  log(`server sent a message: ${serverMsg}`);\n};\n"})})}),(0,a.jsx)(c.A,{value:"Python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py"})})})]}),"\n",(0,a.jsx)(n.p,{children:"Results from running the code:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"connected to server\nclient sent a message: hello\nclient sent a message: hi\nserver sent a message: hello\nserver sent a message: hi\n"})}),"\n",(0,a.jsx)(n.h3,{id:"underlying-type-of-messages",children:"Underlying Type of Messages"}),"\n",(0,a.jsx)(n.p,{children:"Let's focus for a moment to the type of messages that are being exchanged, i.e.\nthe messages sent by client to server or vice versa."}),"\n",(0,a.jsx)(n.p,{children:"Let's only change some parts of previous code example and run it again."}),"\n",(0,a.jsxs)(o.A,{children:[(0,a.jsx)(c.A,{value:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"ws.onopen = function () {\n  console.log('connected to server');\n  ws.send('hello');\n  ws.send(2573);\n  ws.send(true);\n};\n\nws.onmessage = function (event) {\n  const serverMsg = event.data;\n  const msgType = typeof serverMsg;\n  console.log(`server sent a message: ${serverMsg} (${msgType})`);\n};\n"})})}),(0,a.jsx)(c.A,{value:"Python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py"})})})]}),"\n",(0,a.jsx)(n.p,{children:"Results from running the code:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"connected to server\nserver sent a message: hello (string)\nserver sent a message: 2573 (string)\nserver sent a message: true (string)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["As you see, even when we're sending a message with the type of ",(0,a.jsx)(n.code,{children:"number"})," or\n",(0,a.jsx)(n.code,{children:"int"}),", what the server sends back is always ",(0,a.jsx)(n.code,{children:"string"})," or ",(0,a.jsx)(n.code,{children:"str"}),". This is\nnotewortyh because it demonstrates that messages being exchanged between client\nand server are (usually) strings. Techincally, there are\n",(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send#data",children:"other types of messages"}),"\nthat can be transmitted over the network, but in our case of cTrader OpenAPI\nserver, we deal only with strings."]}),"\n",(0,a.jsx)(n.h2,{id:"format-of-messages",children:"Format of Messages"}),"\n",(0,a.jsxs)(n.p,{children:["So far, we established what a message is, and how to send one. Now let's shift\nour focus back to the cTrader OpenAPI server and go back to the\n",(0,a.jsx)(n.a,{href:"./endpoints#an-example",children:"endpoint"})," we were using\n",(0,a.jsx)(n.a,{href:"./establishing-connection",children:"earlier"}),", and let's listen again for incomeing\nserver messages."]}),"\n",(0,a.jsx)(n.p,{children:"Now let's send a message to the cTrader OpenAPI server, and see wha happens:"}),"\n",(0,a.jsxs)(o.A,{children:[(0,a.jsx)(c.A,{value:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const ws = new WebSocket('wss://live.ctraderapi.com:5036');\nconst { log } = console;\n\nws.onopen = function () {\n  log('connected to server');\n  ws.send('hello');\n};\n\nws.onmessage = function (event) {\n  const serverMsg = event.data;\n  log(`server sent a message: ${serverMsg}`);\n};\n\nws.onclose = function () {\n  log('connection closed');\n};\n"})})}),(0,a.jsx)(c.A,{value:"Python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py"})})})]}),"\n",(0,a.jsx)(n.p,{children:"Results:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'connected to server\nserver sent a message: {"payloadType":2142,"payload":{"errorCode":\n                       "INVALID_REQUEST","description":"Malformed JSON message\n                       at 1:6"}}\nconnection closed\n'})}),"\n",(0,a.jsxs)(n.p,{children:["You can see that server did respond to our message, but it sent a long text that\nseems to have a format. That format is\n",(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Scripting/JSON",children:"JSON"}),".\nWhen we want to send a message to the server, we cannot just send any string\nlike ",(0,a.jsx)(n.code,{children:"'hello'"}),". Our messages must have a format and a structure to them, exactly\nlike how server responded to us. So we established that our meessages need to be\nin JSON format, but what's the structure then?"]}),"\n",(0,a.jsxs)(n.p,{children:["The message must be a JSON object with some fields. One of these fields is\n",(0,a.jsx)(n.code,{children:"payloadType"}),", which is an integer number, and is a neccessary field that must\nbe present in all message. Another common (but not present in all messages) is\n",(0,a.jsx)(n.code,{children:"payload"}),", which is another JSON object with its own fields."]}),"\n",(0,a.jsxs)(n.p,{children:["The server only understands a\n",(0,a.jsx)(n.a,{href:"./dictionary-of-all-messages",children:"pre-defined set of messages"}),", so by specifing the\n",(0,a.jsx)(n.code,{children:"payloadType"})," field, your're telling the server which message you're trying to\nsend. Now we're able to select a specific message to send, but how would we send\nextra information that a message may need to convey? That's what's the ",(0,a.jsx)(n.code,{children:"payload"}),"\nfield is for. What field(s) should the ",(0,a.jsx)(n.code,{children:"payload"})," object have depends on what\n",(0,a.jsx)(n.code,{children:"payloadType"})," is being send."]}),"\n",(0,a.jsx)(n.h2,{id:"sending-the-first-message",children:"Sending the First Message"}),"\n",(0,a.jsxs)(n.p,{children:["The first message a client sends to server is a ",(0,a.jsx)(n.code,{children:"payloadType"})," of ",(0,a.jsx)(n.code,{children:"2100"}),', which\nis called "Requesting application authentication". This message must have a\n',(0,a.jsx)(n.code,{children:"payload"})," with two required fields, one is ",(0,a.jsx)(n.code,{children:"clientId"}),", and the other is\n",(0,a.jsx)(n.code,{children:"clientSecret"}),", and both fields must have string values which are part of the\ncredentials you must acquire to be able to identify yourself to the server. So\nlets' send our firt proper message to the server."]}),"\n",(0,a.jsxs)(o.A,{children:[(0,a.jsx)(c.A,{value:"JavaScript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const ws = new WebSocket('wss://live.ctraderapi.com:5036');\nconst { log } = console;\n\nws.onopen = function () {\n  log('connected to server');\n  const clientMsg = {\n    payloadType: 2100,\n    payload: {\n      clientId: '127f2f93c5c36feeed22a97174ce1f03bee9a71892caf6efca447415',\n      clientSecret: '32186df996aee51ab620852086f160ee67e36c7c673bd312b2',\n    },\n  };\n  ws.send(clientMsg);\n};\n\nws.onmessage = function (event) {\n  const serverMsg = event.data;\n  log(`server sent a message: ${serverMsg}`);\n};\n\nws.onclose = function () {\n  log('connection closed');\n};\n"})})}),(0,a.jsx)(c.A,{value:"Python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py"})})})]}),"\n",(0,a.jsx)(n.p,{children:"Results from running the code:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'connected to server\nserver sent a message: {"payloadType":2101}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["As you see from the results, the server repsonds with a ",(0,a.jsx)(n.code,{children:"payloadType"})," of ",(0,a.jsx)(n.code,{children:"2101"}),",\nwhich means success. We will cover this in more detail later, but for now you\nshould know that a ",(0,a.jsx)(n.code,{children:"payloadType"})," that is one number greater than the one we send\nmeans success, and a ",(0,a.jsx)(n.code,{children:"payloadType"})," of ",(0,a.jsx)(n.code,{children:"2142"})," means failure."]})]})}function g(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},9329:(e,n,s)=>{s.d(n,{A:()=>o});s(6540);var t=s(4164);const a={tabItem:"tabItem_Ymn6"};var r=s(4848);function o({children:e,hidden:n,className:s}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,t.A)(a.tabItem,s),hidden:n,children:e})}}}]);