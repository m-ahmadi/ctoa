"use strict";(self.webpackChunkctrader_openapi_docs=self.webpackChunkctrader_openapi_docs||[]).push([[1349],{5537:(e,n,t)=>{t.d(n,{A:()=>j});var o=t(6540),s=t(4164),r=t(5627),a=t(6347),c=t(372),i=t(604),l=t(1861),d=t(8749);function u(e){return o.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,o.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,o.useMemo)(()=>{const e=n??function(e){return u(e).map(({props:{value:e,label:n,attributes:t,default:o}})=>({value:e,label:n,attributes:t,default:o}))}(t);return function(e){const n=(0,l.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function h({value:e,tabValues:n}){return n.some(n=>n.value===e)}function f({queryString:e=!1,groupId:n}){const t=(0,a.W6)(),s=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,i.aZ)(s),(0,o.useCallback)(e=>{if(!s)return;const n=new URLSearchParams(t.location.search);n.set(s,e),t.replace({...t.location,search:n.toString()})},[s,t])]}function b(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,r=p(e),[a,i]=(0,o.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!h({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:r})),[l,u]=f({queryString:t,groupId:s}),[b,m]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,s]=(0,d.Dv)(n);return[t,(0,o.useCallback)(e=>{n&&s.set(e)},[n,s])]}({groupId:s}),g=(()=>{const e=l??b;return h({value:e,tabValues:r})?e:null})();(0,c.A)(()=>{g&&i(g)},[g]);return{selectedValue:a,selectValue:(0,o.useCallback)(e=>{if(!h({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);i(e),u(e),m(e)},[u,m,r]),tabValues:r}}var m=t(9136);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var w=t(4848);function y({className:e,block:n,selectedValue:t,selectValue:o,tabValues:a}){const c=[],{blockElementScrollPositionUntilNextRender:i}=(0,r.a_)(),l=e=>{const n=e.currentTarget,s=c.indexOf(n),r=a[s].value;r!==t&&(i(n),o(r))},d=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}n?.focus()};return(0,w.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":n},e),children:a.map(({value:e,label:n,attributes:o})=>(0,w.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{c.push(e)},onKeyDown:d,onClick:l,...o,className:(0,s.A)("tabs__item",g.tabItem,o?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function v({lazy:e,children:n,selectedValue:t}){const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=r.find(e=>e.props.value===t);return e?(0,o.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,w.jsx)("div",{className:"margin-top--md",children:r.map((e,n)=>(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function x(e){const n=b(e);return(0,w.jsxs)("div",{className:(0,s.A)("tabs-container",g.tabList),children:[(0,w.jsx)(y,{...n,...e}),(0,w.jsx)(v,{...n,...e})]})}function j(e){const n=(0,m.A)();return(0,w.jsx)(x,{...e,children:u(e.children)},String(n))}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var o=t(6540);const s={},r=o.createContext(s);function a(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(r.Provider,{value:n},e.children)}},8516:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>u});const o=JSON.parse('{"id":"contacting-api/keeping-connection-open","title":"Keeping Connection Open","description":"As mentioned earlier, connection does not stay open","source":"@site/docs/03-contacting-api/06-keeping-connection-open.mdx","sourceDirName":"03-contacting-api","slug":"/contacting-api/keeping-connection-open","permalink":"/ctoa/contacting-api/keeping-connection-open","draft":false,"unlisted":false,"editUrl":"https://github.com/m-ahmadi/ctoa/blob/main/docs/03-contacting-api/06-keeping-connection-open.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{},"sidebar":"sidebar","previous":{"title":"Authentication","permalink":"/ctoa/contacting-api/authentication"},"next":{"title":"Official Packages","permalink":"/ctoa/contacting-api/official-packages"}}');var s=t(4848),r=t(8453),a=t(5537),c=t(9329);const i={},l="Keeping Connection Open",d={},u=[{value:"Note About Python and the <code>websockets</code> Package",id:"note-about-python-and-the-websockets-package",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"keeping-connection-open",children:"Keeping Connection Open"})}),"\n",(0,s.jsxs)(n.p,{children:["As ",(0,s.jsx)(n.a,{href:"./establishing-connection",children:"mentioned earlier"}),", connection does not stay open\nforever, and in order to keep it open, we have to do some extra work."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's use an ",(0,s.jsx)(n.a,{href:"../programming-concepts#infinite-loop",children:"infinite loop"})," and check\nprogramm state at 5 seconds intervals."]}),"\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(c.A,{value:"JavaScript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const ws = new WebSocket('wss://live.ctraderapi.com:5036');\n\n// util functions\nconst { log } = console;\nconst sleep = (secs) => new Promise((r) => setTimeout(r, secs * 1000));\nconst round = (n, dp) => +n.toFixed(dp);\nconst fmt = (n) => round(n / 1000, 1);\n\nconst CHECK_INTERVAL_SECS = 5;\nlet timeWhenOpened = 0;\n\nws.onopen = function () {\n  timeWhenOpened = Date.now();\n  log('connected to server');\n};\n\nws.onclose = function () {\n  log('connection closed');\n};\n\n(async () => {\n  while (true) {\n    await sleep(0);\n    if (ws.readyState !== WebSocket.OPEN) continue;\n\n    const timeBeenOpen = Date.now() - timeWhenOpened;\n    log('connection is been open for', fmt(timeBeenOpen), 'seconds');\n\n    await sleep(CHECK_INTERVAL_SECS);\n  }\n})();\n"})})}),(0,s.jsx)(c.A,{value:"Python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",children:"import asyncio as aio\nimport websockets\nfrom websockets.asyncio.client import connect\nfrom timeit import default_timer as timer\n\nCHECK_INTERVAL_SECS = 5\ntime_when_opened = 0\n\nasync def main():\n\n  async with connect('wss://live.ctraderapi.com:5036') as ws:\n    print('connected to server')\n    time_when_opened = timer()\n\n    while True:\n      await aio.sleep(0)\n\n      if ws.state != websockets.State.OPEN:\n        print('connection closed')\n        break\n\n      time_been_open = round(timer() - time_when_opened, 1)\n      print('connection is been open for', time_been_open, 'seconds')\n\n      await aio.sleep(CHECK_INTERVAL_SECS)\n\naio.run(main())\n"})})})]}),"\n",(0,s.jsx)(n.p,{children:"Results from running the code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"connected to server\nconnection is been open for 0 seconds\nconnection is been open for 5 seconds\nconnection is been open for 10.1 seconds\nconnection is been open for 15.1 seconds\nconnection is been open for 20.1 seconds\nconnection is been open for 25.1 seconds\nconnection closed\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As we learned\n",(0,s.jsx)(n.a,{href:"./establishing-connection#why-connection-closes-automatically",children:"here"})," , the\nconnection gets closed by the server after being idle for about 30 seconds."]}),"\n",(0,s.jsx)(n.p,{children:"Now that we have the ability to detect how long our connection has been open, we\ncan prevent the connection from being closed by repeatedly sending a special\nmessage to the server at intervals that are under 30 seconds. Let's add below\nparts to our previous code and run it again:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let timeOfLastAction = 0;\n\nws.onopen = function () {\n  timeOfLastAction = Date.now();\n  // ...\n};\n\n(async () => {\n  while (true) {\n    // ...\n    const idleTime = fmt(Date.now() - timeOfLastAction);\n    if (idleTime >= 25) {\n      ws.send(JSON.stringify({ payloadType: 51 }));\n      timeOfLastAction = Date.now();\n      log('we just sent heartbeat');\n    }\n    // ...\n  }\n})();\n"})}),"\n",(0,s.jsx)(n.p,{children:"Results from running the code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"connected to server\nconnection is been open for 0 seconds\nconnection is been open for 5 seconds\nconnection is been open for 10.1 seconds\nconnection is been open for 15.1 seconds\nconnection is been open for 20.1 seconds\njust sent heartbeat\nconnection is been open for 25.1 seconds\nconnection closed: { code: 1000, reason: 'Bye', wasClean: true }\n"})}),"\n",(0,s.jsx)(n.p,{children:"As you see from the results, connection did not stay open and it got closed by\nserver again after idle time reached around 30 seconds. So why our heartbeat\nsending didn't have any effects? It's because we did not authenticate first. You\ncan think about it this way, imagine you're the server, and every one that\nconnects to you consumes a little bit of your resources, so you let anyone\nconnect for 30 seconds and you don't say anything because you're a nice server,\nbut if clients want to stay for longer than 30 seconds, they have to show some\nID, so at least server knows it's not wasting its resources on a stranger."}),"\n",(0,s.jsx)(n.p,{children:"So let's add the showing our ID part to our previous code and run it again:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { clientId, clientSecret } = require('./credentials.json');\n\nws.onopen = function () {\n  // ...\n  ws.send(\n    JSON.stringify({ payloadType: 2100, payload: { clientId, clientSecret } }),\n  );\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"Results from running the code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'connected to server\nconnection is been open for 0 seconds\nserver sent: {"payloadType":2101}\nconnection is been open for 5 seconds\nconnection is been open for 10.1 seconds\nconnection is been open for 15.1 seconds\nconnection is been open for 20.1 seconds\nwe just sent heartbeat\nconnection is been open for 25.1 seconds\nserver sent: {"payloadType":51}\nconnection is been open for 30.2 seconds\nconnection is been open for 35.2 seconds\nconnection is been open for 40.2 seconds\nwe just sent heartbeat\nconnection is been open for 45.3 seconds\nconnection is been open for 50.3 seconds\nconnection is been open for 55.3 seconds\nserver sent: {"payloadType":51}\nconnection is been open for 60.4 seconds\nwe just sent heartbeat\nconnection is been open for 65.4 seconds\nconnection is been open for 70.4 seconds\n'})}),"\n",(0,s.jsx)(n.p,{children:"As you see from the results, we succeeded in keeping the connection open for\nlonger than 30 seconds. You might have also noticed that not only we're sending\nthe heartbeat, but the server is also sending us a heartbeat."}),"\n",(0,s.jsxs)(n.h2,{id:"note-about-python-and-the-websockets-package",children:["Note About Python and the ",(0,s.jsx)(n.code,{children:"websockets"})," Package"]}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["In Python, the ",(0,s.jsx)(n.code,{children:"websockets"}),' package automatically keeps connection open by\nsending "WebSocket control frames" specifically, "Ping/Pong frames" which are\npart of the WebSocket protocol itself\n',(0,s.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/rfc6455",children:"RFC 6455"}),"."]}),(0,s.jsx)(n.p,{children:'This shows that the server only checks for network liveness (i.e., "is the TCP\nconnection still responsive?"), therefore the automatic underlaying Ping/Pong\nframes are enough to keep the connection open without sending application level\nheartbeats.'})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},9329:(e,n,t)=>{t.d(n,{A:()=>a});t(6540);var o=t(4164);const s={tabItem:"tabItem_Ymn6"};var r=t(4848);function a({children:e,hidden:n,className:t}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,o.A)(s.tabItem,t),hidden:n,children:e})}}}]);