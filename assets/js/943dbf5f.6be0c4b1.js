"use strict";(self.webpackChunkctrader_openapi_docs=self.webpackChunkctrader_openapi_docs||[]).push([[700],{4178:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"contacting-api/protobuf/index","title":"Protobuf","description":"So far we learned about the structure of messages that we\'re exchanging with the","source":"@site/docs/02-contacting-api/07-protobuf/index.mdx","sourceDirName":"02-contacting-api/07-protobuf","slug":"/contacting-api/protobuf/","permalink":"/ctoa/contacting-api/protobuf/","draft":false,"unlisted":false,"editUrl":"https://github.com/m-ahmadi/ctoa/blob/main/docs/02-contacting-api/07-protobuf/index.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Program Lifecycle","permalink":"/ctoa/contacting-api/program-lifecycle"},"next":{"title":"Compiler and Runtime","permalink":"/ctoa/contacting-api/protobuf/compiler-and-runtime"}}');var r=n(4848),s=n(8453);const a={},i="Protobuf",c={},h=[];function d(e){const t={code:"code",h1:"h1",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"protobuf",children:"Protobuf"})}),"\n",(0,r.jsxs)(t.p,{children:["So far we learned about the structure of messages that we're exchanging with the\nserver, which was ",(0,r.jsx)(t.code,{children:"JSON"}),". There is also another structure that we can use, and\nthat is ",(0,r.jsx)(t.code,{children:"Protobuf"}),". One reason we started with ",(0,r.jsx)(t.code,{children:"JSON"})," structre was that it's a\nsimpler approach, and therefore makes the code example shorter, which in turn\nallowes the reader to focus more on the bigger picture being described. You\nmight ask then what's the point of using this other structure."]}),"\n",(0,r.jsxs)(t.p,{children:["The messages in ",(0,r.jsx)(t.code,{children:"Protobuf"})," structure are much shorter in size compared to\n",(0,r.jsx)(t.code,{children:"JSON"}),", and that results in less data being transmitted over the network. It\nmight seem that using the ",(0,r.jsx)(t.code,{children:"Protobuf"})," is the absolute better choice, but it's not\nthat simple. One can argue against the use of ",(0,r.jsx)(t.code,{children:"Protobuf"})," in some cases. Using\n",(0,r.jsx)(t.code,{children:"Protobuf"})," makes more sense when there are multiple clients connecting to the\nserver, and by more we mean thousands and thousands more. Usualy if your program\nhas less than a 1000 clients, the difference between trafic being saved is not\nworth the hassles of dealing with ",(0,r.jsx)(t.code,{children:"Protobuf"}),". We later see an example of\ncomparing the size of messages in these two strucures and a way to roughly\ncalculate the amount of traffic base on the ",(0,r.jsx)(t.code,{children:"RATE_LIMIT"})," concept."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"Protobuf"})," is a data interchange language developed by Google, and it has its\nown syntax for defining data structures and rules and relationship between them.\nThe contents in this langauge are written in files with a ",(0,r.jsx)(t.code,{children:".proto"})," extension. In\norder to use these files in a programming language, they must be compiled first,\nand to do that we need to install its compiler."]})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var o=n(6540);const r={},s=o.createContext(r);function a(e){const t=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);