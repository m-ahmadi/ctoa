"use strict";(self.webpackChunkctrader_openapi_docs=self.webpackChunkctrader_openapi_docs||[]).push([[6360],{3019:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>i,contentTitle:()=>r,default:()=>p,frontMatter:()=>c,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"examples/py-json-altcode","title":"Python With JSON Communication and Custom WebSocket Class","description":"How to run:","source":"@site/docs/06-examples/09-py-json-altcode.mdx","sourceDirName":"06-examples","slug":"/examples/py-json-altcode","permalink":"/ctoa/examples/py-json-altcode","draft":false,"unlisted":false,"editUrl":"https://github.com/m-ahmadi/ctoa/blob/main/docs/06-examples/09-py-json-altcode.mdx","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{},"sidebar":"sidebar","previous":{"title":"Basic Python example of how to connect to server (JSON, Alt Naming)","permalink":"/ctoa/examples/py-json-connect-getsyms-alt"},"next":{"title":"JavaScript example of how to connect to server and place an order","permalink":"/ctoa/examples/js-connect-place-order"}}');var o=s(4848),a=s(8453);const c={},r="Python With JSON Communication and Custom WebSocket Class",i={},l=[{value:"The <code>WebSocket</code> Class",id:"the-websocket-class",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsxs)(n.h1,{id:"python-with-json-communication-and-custom-websocket-class",children:["Python With JSON Communication and Custom ",(0,o.jsx)(n.code,{children:"WebSocket"})," Class"]})}),"\n",(0,o.jsx)(n.p,{children:"How to run:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"pip install websockets"})}),"\n",(0,o.jsxs)(n.li,{children:["put ",(0,o.jsx)(n.code,{children:"credentials.json"})," right beside the script"]}),"\n",(0,o.jsxs)(n.li,{children:["put ",(0,o.jsx)(n.code,{children:"OAModel.custom.json"})," and ",(0,o.jsx)(n.code,{children:"payloadTypes.custom.json"})," right beside the\nscript. (check\n",(0,o.jsx)(n.a,{href:"./py-json-connect-getsyms-alt#how-to-get-the-json-definition-files",children:"here"})," to\nsee how to create them)"]}),"\n",(0,o.jsxs)(n.li,{children:["put ",(0,o.jsx)(n.a,{href:"#the-websocket-class",children:"WebSocket"})," definition in a file named\n",(0,o.jsx)(n.code,{children:"WebSocket.py"}),", and place it beside the script."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import asyncio as aio\nimport json\nfrom types import SimpleNamespace\nfrom WebSocket import WebSocket # our custom class\n\n# gen util\nparsejson = lambda s: json.loads(s, object_hook=lambda d: SimpleNamespace(**d))\ndef readfile(path):\n  with open(path) as f:\n    return parsejson(f.read())\n\n\ncreds = readfile('./credentials.json')\noa = readfile('./OAModel.custom.json')\npt = readfile('./payloadTypes.custom.json')\n\n# app util\ndef construct_msg(payloadType, fields={}, clientMsgId=''):\n  msg = {\n    'payloadType': payloadType,\n    'payload': {\n      'ctidTraderAccountId': creds.accountId,\n      'accessToken': creds.accessToken,\n      **fields\n    }\n  }\n  if clientMsgId:\n    msg['clientMsgId'] = clientMsgId\n  return json.dumps(msg)\n\n\n\n# application code\n\n# application's starting point\n# called after the program is connected to server and fully authenticated\nasync def on_ready(ws):\n  print('on ready')\n\n  # get symbols list\n  msg = construct_msg(pt.req.SymbolsList, {'symbolId':41})\n  await ws.send(msg)\n\n  # subscribe to live price\n  msg = construct_msg(pt.req.SubscribeSpots, {'symbolId':41})\n  await ws.send(msg)\n\n  # place limit order on XAUUSD symbol with volume of 0.01 lot\n  msg = construct_msg(pt.req.NewOrder, {\n    'symbolId': 41,\n    'orderType': oa.OrderType.LIMIT,\n    'tradeSide': oa.TradeSide.BUY,\n    'volume': 100,\n    'limitPrice': 3800.00,\n    'stopLoss': 3600.00,\n    'takeProfit': 4200.00\n  })\n  await ws.send(msg)\n\n\n# application's main message callback\n# called upon incomming server messages (except heartbeat msgs)\nasync def on_resp(ws, msg_str):\n  msg = json.loads(msg_str) # parse json as dict\n  # msg = parsejson(msg_str) # parse json as obj\n  payloadType = msg['payloadType']\n  payload = msg['payload']\n\n  if payloadType == pt.res.SymbolsList:\n    with open('symbols.json', 'w') as f:\n      syms = payload['symbol']\n      json.dump(syms, f, indent=2)\n\n  if payloadType == pt.event.Execution:\n    print('order executed')\n    print(json.dumps(payload, indent=2))\n\n\n\n\n# code related to setting up connection and authentication\nasync def main():\n  ws = WebSocket('wss://live.ctraderapi.com:5036')\n\n  async def on_open():\n    print('connected')\n    # we don't use the `construct_msg()` function for the first message,\n    # because its payload is different from the rest of the messages\n    msg = {\n      'payloadType': pt.req.ApplicationAuth,\n      'payload': {\n        'clientId': creds.clientId,\n        'clientSecret': creds.clientSecret\n      }\n    }\n    await ws.send(json.dumps(msg))\n\n  async def on_message(msg_str):\n    # we're defining a hardcoded behaviour for special incomming messages\n    # and redirecting the rest of the messages to the `on_resp()` function\n    msg = parsejson(msg_str)\n    payloadType = msg.payloadType\n    if payloadType == pt.res.ApplicationAuth:\n      print('auth app')\n      msg = construct_msg(pt.req.AccountAuth)\n      await ws.send(msg)\n      return\n    if payloadType == pt.res.AccountAuth:\n      print('auth account')\n      await on_ready(ws)\n      return\n    if payloadType == pt.common.HeartbeatEvent:\n      msg = {'payloadType': pt.common.HeartbeatEvent}\n      await ws.send(json.dumps(msg))\n      print('heartbeat exchange')\n      return\n    await on_resp(ws, msg_str)\n\n  async def on_close():\n    print('closed')\n\n  async def on_error(err):\n    print('error:', err)\n\n  ws.onopen = on_open\n  ws.onmessage = on_message\n  ws.onclose = on_close\n  ws.onerror = on_error\n\n  # keep running the loop until WebSocket closes\n  while ws.readyState != WebSocket.CLOSED:\n    await aio.sleep(0.1)\n\n\naio.run(main())\n\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"the-websocket-class",children:["The ",(0,o.jsx)(n.code,{children:"WebSocket"})," Class"]}),"\n",(0,o.jsx)(n.p,{children:"This is just a wrapper class that tries to mimic Browser's WebSocket API."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import asyncio\nimport websockets\n\n\nclass WebSocket:\n  CONNECTING = 0\n  OPEN = 1\n  CLOSING = 2\n  CLOSED = 3\n\n  def __init__(self, url):\n    self.url = url\n    self.readyState = WebSocket.CONNECTING\n    self.onopen = None\n    self.onmessage = None\n    self.onclose = None\n    self.onerror = None\n    self._ws = None\n    self._loop = asyncio.get_event_loop()\n    self._loop.create_task(self._connect())\n\n  async def _connect(self):\n    try:\n      async with websockets.connect(self.url) as ws:\n        self._ws = ws\n        self.readyState = WebSocket.OPEN\n        if callable(self.onopen):\n          await self._maybe_await(self.onopen())\n\n        async for message in ws:\n          if callable(self.onmessage):\n            await self._maybe_await(self.onmessage(message))\n\n    except Exception as e:\n      if callable(self.onerror):\n        await self._maybe_await(self.onerror(e))\n    finally:\n      self.readyState = WebSocket.CLOSED\n      if callable(self.onclose):\n        await self._maybe_await(self.onclose())\n\n  async def send(self, data):\n    if self.readyState == WebSocket.OPEN and self._ws:\n      await self._ws.send(data)\n    else:\n      raise ConnectionError('WebSocket is not open')\n\n  async def close(self):\n    if self._ws and self.readyState == WebSocket.OPEN:\n      self.readyState = WebSocket.CLOSING\n      await self._ws.close()\n      self.readyState = WebSocket.CLOSED\n\n  async def _maybe_await(self, result):\n    '''Allow both sync and async callbacks.'''\n    if asyncio.iscoroutine(result):\n      await result\n\n"})}),"\n",(0,o.jsxs)(n.admonition,{type:"note",children:[(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"websockets"}),' package automatically keeps connection open by sending\n"WebSocket control frames" specifically, "Ping/Pong frames" which are part of\nthe WebSocket protocol itself\n',(0,o.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/rfc6455",children:"RFC 6455"}),"."]}),(0,o.jsx)(n.p,{children:'This shows that the server only checks for network liveness (i.e., "is the TCP\nconnection still responsive?"), therefore the automatic underlaying Ping/Pong\nframes are enough to keep the connection open without sending application level\nheartbeats.'})]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>r});var t=s(6540);const o={},a=t.createContext(o);function c(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);